use std::collections::*;
use crate::util::*;

#[allow(dead_code)]
fn parse(input: &str) -> usize {


    0
}

pub fn p1(input: &str) -> usize {
    let mut uniq = HashSet::new();
    let mut qt = 0;
    let grid = input_to_char_grid(input);
    let rows = grid.len();
    let cols = grid[0].len();
    
    for (r, row) in grid.it() {
        for (c, l) in row.it() {
            let l = *l;
            if l == '.' { continue; }
            // check right
            if c + 2 < cols && l == grid[r][c + 2] {
                if c >= 2 { uniq.insert((r, c - 2)); qt += 1; qt += 1; }
                if c + 4 < cols { uniq.insert((r, c + 4)); qt += 1; }
            }

            // check down
            if r + 2 < rows && l == grid[r + 2][c] {
                if r >= 2 { uniq.insert((r - 2, c)); qt += 1; }
                if r + 4 < rows { uniq.insert((r + 4, c));  qt += 1;}
            }

            // check 2 down 1 right
            if r + 2 < rows && c + 1 < cols && l == grid[r + 2][c + 1] {
                if r >= 2 && c >= 1 { uniq.insert((r - 2, c - 1)); qt += 1; }
                if r + 4 < rows && c + 2 < cols { uniq.insert((r + 4, c + 2)); qt += 1; }
            }

            // check 1 down 2 right
            if r + 1 < rows && c + 2 < cols && l == grid[r + 1][c + 2] {
                if r >= 1 && c >= 2 { uniq.insert((r - 1, c - 2)); qt += 1; }
                if r + 2 < rows && c + 4 < cols { uniq.insert((r + 2, c + 4)); qt += 1; }
            }

            // check 2 down 1 left
            if r + 2 < rows && c >= 1 && l == grid[r + 2][c - 1] {
                if r >= 2 && c + 1 < cols { uniq.insert((r - 2, c + 1)); qt += 1; }
                if r + 4 < rows && c >= 2 { uniq.insert((r + 4, c - 2)); qt += 1; }
            }

            // check 1 down 2 left
            if r + 1 < rows && c >= 2 && l == grid[r + 1][c - 2] {
                if r >= 1 && c + 2 < cols { uniq.insert((r - 1, c + 2)); qt += 1; }
                if r + 2 < rows && c >= 4 { uniq.insert((r + 2, c - 4)); qt += 1; }
            }
        }
    }

    dbg!(uniq.len());
    qt
}

pub fn p2(input: &str) -> usize {


    0
}



#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_p1_sample() {
        assert_eq!(171, p1(SAMPLE));
    }

    #[test]
    #[ignore]
    fn test_p1_in() {
        assert_eq!(171, p1(IN));
    }

    #[test]
    #[ignore]
    fn test_p2_sample() {
        assert_eq!(171, p1(SAMPLE));
    }

    #[test]
    #[ignore]
    fn test_p2_in() {
        assert_eq!(171, p2(IN));
    }
}


// -------------------------- INPUT



pub static SAMPLE: &str = "............
........0...
.....0......
.......0....
....0.......
......A.....
............
............
........A...
.........A..
............
............";

pub static IN: &str = "..................................w...............
..................................................
.....................................C............
......................................3...........
.............b.......u.........w...........3......
...........................u......................
...8........K...........u.......y.........I.......
..................................P5........B.....
...U................2.P...............B...C.......
............i......x.P........w......s.C......IB5.
..............t....................y....x.........
.......8............K....1.......w............u...
.................i.............r.........s........
..2.............t..T.K.......r......8..........I..
8..............t..T.....r...................5.....
...2........................1....M.t...N....x.....
...V....U.......................N.S..........I....
.........W...i............O....v............S.....
................L...1...s.fT.....x............3...
....6.......C...N.........Tf.3....................
...6.......F..........V..........k...N......H.....
...................U..f........0......H.y.........
.......................O...P......0...............
.......L..U....m.......R............s.............
6...i.................O....0.2.........H.....B....
........................R......H.........S........
......F.....c..........m..............d...........
................F.L.....m..................7......
.............J.........................S..........
.b....j.k..............V0.........................
.................L.....K..........................
.......F.......J..............r.....M.............
......................m1....a.R...7...............
.......4......Y..6.D..............................
k............9.......D................M...........
.....Xb.................V...h.....................
A.........9.Xl..........D......R..................
4.............c..d........D.............7.........
.A.4.............c.............M.7.v..............
..........n.9........................h............
...j....bd.........f.....p..W.....................
.............k.........p..........................
.......W4.......p......X.....5..J.....v...........
........W.d..c......A........n..v.....o...........
..........l.....n..........o......Y...h...........
.....A............................................
..j..........n....................................
a9.lX..................Y...........o..............
.......a.................Y..........o.............
...a....l.......................p.................";
